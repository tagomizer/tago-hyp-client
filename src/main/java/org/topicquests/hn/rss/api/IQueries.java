/**
 * 
 */
package org.topicquests.hn.rss.api;

/**
 * @author jackpark
 *
 */
public interface IQueries {

	///////////////////////
	// Core Queries
	///////////////////////
	// int limit, int offset"
	public static final String FetchAllStories =
			"SELECT p.id, p.title, url.url FROM public.post as p "+
					"JOIN public.url ON  url.id = p.story_url "+
			"LIMIT ? OFFSET ?";
	
	public static final String FetchAllURLS =
			"SELECT public.url.url, public.post.title FROM public.url "+
			"JOIN public.post.title ON public.post.story_url = public.url.id "+
			"LIMIT ? OFFSET ?";
	
	public static final String FetchAllAuthors =
			"SELECT * FROM public.author LIMIT ? OFFSET ?";
	public static final String FetchAllTags =
			"";
	//TODO NEED a query which fetches a Story and all its child nodes (comments)
	
	// Fetch by Author 
	//	Can return All Entities -- maybe need Fetch Story by Author and Fetch Comments by Author
	//  trouble is, posts can be a job, poll, story, comment, or pollopt so just fetch by author is the simplest and required
	//  can add specialty post type fetches as well
	public static final String fetchAllByAuthor =
			""; //TODO
	public static final String fetchStoriesByAuthor =
			""; //TODO
	public static final String fetchCommentsByAuthor =
			""; //TODO
	public static final String fetchPollsByAuthor =
			""; //TODO
	/////////////////////////////////////////////
	// A general fetch query with help from MAP
	// with q as (select ancestry from public.post where ext_id = ?) 
	//		select c.id, c.parent_id, c.ancestry from public.post c join q on true where c.ancestry <@ q.ancestry
	// where "ext_id" could be author, url, etc
	/////////////////////////////////////////////
	// Fetch by URL
	//	these are important for "have I seen this before?" queries
	public static final String fetchByURL =
			""; //TODO
	// Fetch by Title
	public static final String fetchByTitle =
			""; //TODO
	// search on text
	
	// Put Entity (putPost)
	public static final String putEntity = 
		"INSERT into public.post (post_type, ext_source, ext_id, author, story_url, "+
			"pub_time, mod_time, score, descendents, lang, is_dead, is_deleted, title, body, parent) "+
			"VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id"; 
	
	// Get Entity by ID  --- serves exists?
	public static final String getEntityById =
			""; //TODO
	// Get Entity recursive by ID
	// This one can deal with a story and its comments tree
	// NOTE the ancestry value is a string, not an int
	// Given some nodeId, get its descendants
	// select * from post  where ancestry ~ '*.44.*'; allows you to start in the middle of a tree
	// NOTE: "?" needs the ID generated by postgres,not the hackernews ID
	public static final String getRecursiveEntityById =
			"SELECT p.id, p.post_type, p.ext_source, p.ext_id, p.author, p.story_url, "+
				"p.pub_time, p.mod_time, p.score, p.descendents, p.lang, p.is_dead, "+
				"p.is_deleted, p.title, p.body, p.parent, p.ancestry, url.url, "+
				"author.text "+
			"FROM public.post AS p "+
				"JOIN public.url ON url.id = p.story_url "+
				"JOIN public.author ON author.id = p.author "+
			"WHERE p.ancestry <@ CAST(? as ltree)";

	
	// test for any post object by way of the HackerNews ID
	// returns the postgres ID
	public static final String existsObject =
		"SELECT id from public.post WHERE ext_id = ?";


	// remove post object by its postgres ID
	public static final String removeObject =
		"DELETE from public.post WHERE id = ?";
	
	// does not recurse on children by way of its postgres ID
	public static final String getObject =
		"SELECT p.id, p.post_type, p.ext_source, p.ext_id, p.author, p.story_url, "+
			"p.pub_time, p.mod_time, p.score, p.descendents, p.lang, p.is_dead, "+
			"p.is_deleted, p.title, p.body, p.parent, p.ancestry, url.url, "+
			"author.text "+
		"FROM public.post AS p "+
			"JOIN public.url ON url.id = p.story_url "+
			"JOIN public.author ON author.id = p.author "+
		"WHERE p.id=?";


	public static final String updateScore = 
		"UPDATE public.post SET score=? WHERE id=?";
	
	public static final String updateDescendentCount =
		"UPDATE public.post SET descendents=? WHERE id=?";
	
	public static final String insertTag =
		"INSERT INTO public.tag (tag) VALUES(?) RETURNING id";
	public static final String addTagToPost =
		"INSERT INTO public.tag_post (post_id, tag_id) VALUES(?, ?)";
	public static final String addTagToAuthor =
		"INSERT INTO public.tag_author (author_id, tag_id) VALUES(?, ?)";
	
	public static final String getTagsByTagId =
		"SELECT public.tag_post.id, public.tag.tag FROM public.tag.post "+
		"WHERE id=? "+
		"JOIN public.tag.tag ON public.post.tag.id = public.post_tag.post_id";
	public static final String getTagsByPost =
		"SELECT public.tag_post.tag_id, public.tag.tag FROM public.tag_post "+
		"WHERE post_id=? "+
		"JOIN public.post.tag ON public.post.tag.id = public.tag.id";
	public static final String getTagsByAuthort =
			"SELECT public.tag_author.tag_id, public.tag.tag FROM public.tag_author "+
			"WHERE author_id=? "+
			"JOIN public.tag.tag ON public.tag_author.tag.id = public.tag.id";
	
	public static final String listEntities = 
			"SELECT * FROM public.post LIMIT ? OFFSET ?";
	///////////////////
	// support queries
	///////////////////
	
	// same as getRecursiveEntityById
	public static final String fetchLTree =
			"SELECT * FROM public.post WHERE ancestry  @< ?";
	
	public static final String getURLId =
			"SELECT id FROM public.url WHERE url = ?";
	
	//TODO RETURNING - need to validate that postgres driver can handle that
	// we cannot handle returns
	public static final String insertURL =
			"INSERT into public.url (url) VALUES (?) RETURNING id";
	
	public static final String getAuthorId =
			"SELECT id FROM public.author where text = ?";
	
	public static final String insertAuthor =
			"INSERT into public.author (text) VALUES (?) RETURNING id";
	////////////
	// We can imagine a library of research queries.
	// For example: 
	//	how many times does an author post the same story?
	///////////////////
}
